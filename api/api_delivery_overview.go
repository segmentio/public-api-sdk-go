/*
Segment Public API

The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.

API version: 47.0.0
Contact: friends@segment.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// DeliveryOverviewAPIService DeliveryOverviewAPI service
type DeliveryOverviewAPIService service

type ApiGetEgressFailedMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewDestMetricsBetaInput
}

// Metrics for this Destination pipeline step.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewDestMetricsBetaInput,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetEgressFailedMetricsFromDeliveryOverviewExecute(r)
}

/*
GetEgressFailedMetricsFromDeliveryOverview Get Egress Failed Metrics from Delivery Overview

Get events that failed to be delivered to Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEgressFailedMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetEgressFailedMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	return ApiGetEgressFailedMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetEgressFailedMetricsFromDeliveryOverviewExecute(
	r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetEgressFailedMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/failed-delivery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewDestMetricsBetaInput
}

// Metrics for this Destination pipeline step.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewDestMetricsBetaInput,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetEgressSuccessMetricsFromDeliveryOverviewExecute(r)
}

/*
GetEgressSuccessMetricsFromDeliveryOverview Get Egress Success Metrics from Delivery Overview

Get events successfully delivered to Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetEgressSuccessMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	return ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetEgressSuccessMetricsFromDeliveryOverviewExecute(
	r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetEgressSuccessMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/successful-delivery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewDestMetricsBetaInput
}

// Metrics for this Destination pipeline step.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewDestMetricsBetaInput,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetFilteredAtDestinationMetricsFromDeliveryOverviewExecute(r)
}

/*
GetFilteredAtDestinationMetricsFromDeliveryOverview Get Filtered At Destination Metrics from Delivery Overview

Get events that were filtered at Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetFilteredAtDestinationMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	return ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetFilteredAtDestinationMetricsFromDeliveryOverviewExecute(
	r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetFilteredAtDestinationMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/filtered-at-destination"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewSourceMetricsBetaInput
}

// Metrics for this Source pipeline step.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewSourceMetricsBetaInput,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetFilteredAtSourceMetricsFromDeliveryOverviewExecute(r)
}

/*
GetFilteredAtSourceMetricsFromDeliveryOverview Get Filtered At Source Metrics from Delivery Overview

Get events that were filtered at Source.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetFilteredAtSourceMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	return ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetFilteredAtSourceMetricsFromDeliveryOverviewExecute(
	r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetFilteredAtSourceMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/filtered-at-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngressFailedMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewSourceMetricsBetaInput
}

// Metrics for this Source pipeline step.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewSourceMetricsBetaInput,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetIngressFailedMetricsFromDeliveryOverviewExecute(r)
}

/*
GetIngressFailedMetricsFromDeliveryOverview Get Ingress Failed Metrics from Delivery Overview

Get events that failed on ingest.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIngressFailedMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetIngressFailedMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	return ApiGetIngressFailedMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetIngressFailedMetricsFromDeliveryOverviewExecute(
	r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetIngressFailedMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/failed-on-ingest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest struct {
	ctx        context.Context
	ApiService *DeliveryOverviewAPIService
	metrics    *GetDeliveryOverviewSourceMetricsBetaInput
}

// Metrics for this Source pipeline step.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Metrics(
	metrics GetDeliveryOverviewSourceMetricsBetaInput,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.metrics = &metrics
	return r
}

func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetIngressSuccessMetricsFromDeliveryOverviewExecute(r)
}

/*
GetIngressSuccessMetricsFromDeliveryOverview Get Ingress Success Metrics from Delivery Overview

Get events that were successfully received by Segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetIngressSuccessMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	return ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetIngressSuccessMetricsFromDeliveryOverviewExecute(
	r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetIngressSuccessMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/successfully-received"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metrics == nil {
		return localVarReturnValue, nil, reportError("metrics is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metrics", r.metrics, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Segment Public API

The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.

API version: 72.1.0
Contact: friends@segment.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
)

// DeliveryOverviewAPIService DeliveryOverviewAPI service
type DeliveryOverviewAPIService service

type ApiGetEgressFailedMetricsFromDeliveryOverviewRequest struct {
	ctx                 context.Context
	ApiService          *DeliveryOverviewAPIService
	sourceId            *string
	destinationConfigId *string
	startTime           *string
	endTime             *string
	granularity         *string
	groupBy             *[]string
	filter              *DeliveryOverviewDestinationFilterBy
	pagination          *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The id tied to a Workspace Destination.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) DestinationConfigId(
	destinationConfigId string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.destinationConfigId = &destinationConfigId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and/or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewDestinationFilterBy,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetEgressFailedMetricsFromDeliveryOverviewExecute(r)
}

/*
GetEgressFailedMetricsFromDeliveryOverview Get Egress Failed Metrics from Delivery Overview

Get events that failed to be delivered to Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEgressFailedMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetEgressFailedMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetEgressFailedMetricsFromDeliveryOverviewRequest {
	return ApiGetEgressFailedMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetEgressFailedMetricsFromDeliveryOverviewExecute(
	r ApiGetEgressFailedMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetEgressFailedMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/failed-delivery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.destinationConfigId == nil {
		return localVarReturnValue, nil, reportError(
			"destinationConfigId is required and must be specified",
		)
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(
		localVarQueryParams,
		"destinationConfigId",
		r.destinationConfigId,
		"",
	)
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest struct {
	ctx                 context.Context
	ApiService          *DeliveryOverviewAPIService
	sourceId            *string
	destinationConfigId *string
	startTime           *string
	endTime             *string
	granularity         *string
	groupBy             *[]string
	filter              *DeliveryOverviewDestinationFilterBy
	pagination          *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The id tied to a Workspace Destination.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) DestinationConfigId(
	destinationConfigId string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.destinationConfigId = &destinationConfigId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;appVersion&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;. If you would like to view retry attempts for a successful delivery, you can filter &#x60;discard Reason&#x60; from &#x60;successes.attempt.1&#x60; through &#x60;successes.attempt.10&#x60;.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewDestinationFilterBy,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetEgressSuccessMetricsFromDeliveryOverviewExecute(r)
}

/*
GetEgressSuccessMetricsFromDeliveryOverview Get Egress Success Metrics from Delivery Overview

Get events successfully delivered to Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetEgressSuccessMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest {
	return ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetEgressSuccessMetricsFromDeliveryOverviewExecute(
	r ApiGetEgressSuccessMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetEgressSuccessMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/successful-delivery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.destinationConfigId == nil {
		return localVarReturnValue, nil, reportError(
			"destinationConfigId is required and must be specified",
		)
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(
		localVarQueryParams,
		"destinationConfigId",
		r.destinationConfigId,
		"",
	)
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest struct {
	ctx                 context.Context
	ApiService          *DeliveryOverviewAPIService
	sourceId            *string
	destinationConfigId *string
	startTime           *string
	endTime             *string
	granularity         *string
	groupBy             *[]string
	filter              *DeliveryOverviewDestinationFilterBy
	pagination          *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The id tied to a Workspace Destination.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) DestinationConfigId(
	destinationConfigId string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.destinationConfigId = &destinationConfigId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and/or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewDestinationFilterBy,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetFilteredAtDestinationMetricsFromDeliveryOverviewExecute(r)
}

/*
GetFilteredAtDestinationMetricsFromDeliveryOverview Get Filtered At Destination Metrics from Delivery Overview

Get events that were filtered at Destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetFilteredAtDestinationMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest {
	return ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetFilteredAtDestinationMetricsFromDeliveryOverviewExecute(
	r ApiGetFilteredAtDestinationMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetFilteredAtDestinationMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/filtered-at-destination"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.destinationConfigId == nil {
		return localVarReturnValue, nil, reportError(
			"destinationConfigId is required and must be specified",
		)
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(
		localVarQueryParams,
		"destinationConfigId",
		r.destinationConfigId,
		"",
	)
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest struct {
	ctx         context.Context
	ApiService  *DeliveryOverviewAPIService
	sourceId    *string
	startTime   *string
	endTime     *string
	granularity *string
	groupBy     *[]string
	filter      *DeliveryOverviewSourceFilterBy
	pagination  *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and &#x60;app Version&#x60;.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewSourceFilterBy,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Optional params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetFilteredAtSourceMetricsFromDeliveryOverviewExecute(r)
}

/*
GetFilteredAtSourceMetricsFromDeliveryOverview Get Filtered At Source Metrics from Delivery Overview

Get events that were filtered at Source.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetFilteredAtSourceMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest {
	return ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetFilteredAtSourceMetricsFromDeliveryOverviewExecute(
	r ApiGetFilteredAtSourceMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetFilteredAtSourceMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/filtered-at-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngressFailedMetricsFromDeliveryOverviewRequest struct {
	ctx         context.Context
	ApiService  *DeliveryOverviewAPIService
	sourceId    *string
	startTime   *string
	endTime     *string
	granularity *string
	groupBy     *[]string
	filter      *DeliveryOverviewSourceFilterBy
	pagination  *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;appVersion&#x60;.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewSourceFilterBy,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Optional params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetIngressFailedMetricsFromDeliveryOverviewExecute(r)
}

/*
GetIngressFailedMetricsFromDeliveryOverview Get Ingress Failed Metrics from Delivery Overview

Get events that failed on ingest.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIngressFailedMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetIngressFailedMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetIngressFailedMetricsFromDeliveryOverviewRequest {
	return ApiGetIngressFailedMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetIngressFailedMetricsFromDeliveryOverviewExecute(
	r ApiGetIngressFailedMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetIngressFailedMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/failed-on-ingest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest struct {
	ctx         context.Context
	ApiService  *DeliveryOverviewAPIService
	sourceId    *string
	startTime   *string
	endTime     *string
	granularity *string
	groupBy     *[]string
	filter      *DeliveryOverviewSuccessfullyReceivedFilterBy
	pagination  *PaginationInput
}

// The sourceId for the Workspace.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) SourceId(
	sourceId string,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.sourceId = &sourceId
	return r
}

// The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) StartTime(
	startTime string,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.startTime = &startTime
	return r
}

// The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) EndTime(
	endTime string,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.endTime = &endTime
	return r
}

// The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Granularity(
	granularity string,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.granularity = &granularity
	return r
}

// A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, and/or &#x60;app Version&#x60;.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) GroupBy(
	groupBy []string,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.groupBy = &groupBy
	return r
}

// An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Filter(
	filter DeliveryOverviewSuccessfullyReceivedFilterBy,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.filter = &filter
	return r
}

// Optional params to specify the page cursor and count.  This parameter exists in beta.
func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Pagination(
	pagination PaginationInput,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	r.pagination = &pagination
	return r
}

func (r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest) Execute() (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	return r.ApiService.GetIngressSuccessMetricsFromDeliveryOverviewExecute(r)
}

/*
GetIngressSuccessMetricsFromDeliveryOverview Get Ingress Success Metrics from Delivery Overview

Get events that were successfully received by Segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest
*/
func (a *DeliveryOverviewAPIService) GetIngressSuccessMetricsFromDeliveryOverview(
	ctx context.Context,
) ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest {
	return ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEgressFailedMetricsFromDeliveryOverview200Response
func (a *DeliveryOverviewAPIService) GetIngressSuccessMetricsFromDeliveryOverviewExecute(
	r ApiGetIngressSuccessMetricsFromDeliveryOverviewRequest,
) (*GetEgressFailedMetricsFromDeliveryOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEgressFailedMetricsFromDeliveryOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"DeliveryOverviewAPIService.GetIngressSuccessMetricsFromDeliveryOverview",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delivery-overview/successfully-received"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.granularity == nil {
		return localVarReturnValue, nil, reportError(
			"granularity is required and must be specified",
		)
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(
					localVarQueryParams,
					fmt.Sprintf("groupBy.%d", i),
					s.Index(i).Interface(),
					"multi",
				)
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.segment.v1beta+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

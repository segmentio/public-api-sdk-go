/*
Segment Public API

The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.

API version: 58.1.1
Contact: friends@segment.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// TransitionState - struct for TransitionState
type TransitionState struct {
	AudienceEntryState         *AudienceEntryState
	ConditionSplitState        *ConditionSplitState
	DestinationState           *DestinationState
	EventEntryState            *EventEntryState
	EventSplitWithTimeoutState *EventSplitWithTimeoutState
	RandomSplitState           *RandomSplitState
	SimpleDelayState           *SimpleDelayState
}

// AudienceEntryStateAsTransitionState is a convenience function that returns AudienceEntryState wrapped in TransitionState
func AudienceEntryStateAsTransitionState(v *AudienceEntryState) TransitionState {
	return TransitionState{
		AudienceEntryState: v,
	}
}

// ConditionSplitStateAsTransitionState is a convenience function that returns ConditionSplitState wrapped in TransitionState
func ConditionSplitStateAsTransitionState(v *ConditionSplitState) TransitionState {
	return TransitionState{
		ConditionSplitState: v,
	}
}

// DestinationStateAsTransitionState is a convenience function that returns DestinationState wrapped in TransitionState
func DestinationStateAsTransitionState(v *DestinationState) TransitionState {
	return TransitionState{
		DestinationState: v,
	}
}

// EventEntryStateAsTransitionState is a convenience function that returns EventEntryState wrapped in TransitionState
func EventEntryStateAsTransitionState(v *EventEntryState) TransitionState {
	return TransitionState{
		EventEntryState: v,
	}
}

// EventSplitWithTimeoutStateAsTransitionState is a convenience function that returns EventSplitWithTimeoutState wrapped in TransitionState
func EventSplitWithTimeoutStateAsTransitionState(v *EventSplitWithTimeoutState) TransitionState {
	return TransitionState{
		EventSplitWithTimeoutState: v,
	}
}

// RandomSplitStateAsTransitionState is a convenience function that returns RandomSplitState wrapped in TransitionState
func RandomSplitStateAsTransitionState(v *RandomSplitState) TransitionState {
	return TransitionState{
		RandomSplitState: v,
	}
}

// SimpleDelayStateAsTransitionState is a convenience function that returns SimpleDelayState wrapped in TransitionState
func SimpleDelayStateAsTransitionState(v *SimpleDelayState) TransitionState {
	return TransitionState{
		SimpleDelayState: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *TransitionState) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AudienceEntryState
	err = newStrictDecoder(data).Decode(&dst.AudienceEntryState)
	if err == nil {
		jsonAudienceEntryState, _ := json.Marshal(dst.AudienceEntryState)
		if string(jsonAudienceEntryState) == "{}" { // empty struct
			dst.AudienceEntryState = nil
		} else {
			match++
		}
	} else {
		dst.AudienceEntryState = nil
	}

	// try to unmarshal data into ConditionSplitState
	err = newStrictDecoder(data).Decode(&dst.ConditionSplitState)
	if err == nil {
		jsonConditionSplitState, _ := json.Marshal(dst.ConditionSplitState)
		if string(jsonConditionSplitState) == "{}" { // empty struct
			dst.ConditionSplitState = nil
		} else {
			match++
		}
	} else {
		dst.ConditionSplitState = nil
	}

	// try to unmarshal data into DestinationState
	err = newStrictDecoder(data).Decode(&dst.DestinationState)
	if err == nil {
		jsonDestinationState, _ := json.Marshal(dst.DestinationState)
		if string(jsonDestinationState) == "{}" { // empty struct
			dst.DestinationState = nil
		} else {
			match++
		}
	} else {
		dst.DestinationState = nil
	}

	// try to unmarshal data into EventEntryState
	err = newStrictDecoder(data).Decode(&dst.EventEntryState)
	if err == nil {
		jsonEventEntryState, _ := json.Marshal(dst.EventEntryState)
		if string(jsonEventEntryState) == "{}" { // empty struct
			dst.EventEntryState = nil
		} else {
			match++
		}
	} else {
		dst.EventEntryState = nil
	}

	// try to unmarshal data into EventSplitWithTimeoutState
	err = newStrictDecoder(data).Decode(&dst.EventSplitWithTimeoutState)
	if err == nil {
		jsonEventSplitWithTimeoutState, _ := json.Marshal(dst.EventSplitWithTimeoutState)
		if string(jsonEventSplitWithTimeoutState) == "{}" { // empty struct
			dst.EventSplitWithTimeoutState = nil
		} else {
			match++
		}
	} else {
		dst.EventSplitWithTimeoutState = nil
	}

	// try to unmarshal data into RandomSplitState
	err = newStrictDecoder(data).Decode(&dst.RandomSplitState)
	if err == nil {
		jsonRandomSplitState, _ := json.Marshal(dst.RandomSplitState)
		if string(jsonRandomSplitState) == "{}" { // empty struct
			dst.RandomSplitState = nil
		} else {
			match++
		}
	} else {
		dst.RandomSplitState = nil
	}

	// try to unmarshal data into SimpleDelayState
	err = newStrictDecoder(data).Decode(&dst.SimpleDelayState)
	if err == nil {
		jsonSimpleDelayState, _ := json.Marshal(dst.SimpleDelayState)
		if string(jsonSimpleDelayState) == "{}" { // empty struct
			dst.SimpleDelayState = nil
		} else {
			match++
		}
	} else {
		dst.SimpleDelayState = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AudienceEntryState = nil
		dst.ConditionSplitState = nil
		dst.DestinationState = nil
		dst.EventEntryState = nil
		dst.EventSplitWithTimeoutState = nil
		dst.RandomSplitState = nil
		dst.SimpleDelayState = nil

		return fmt.Errorf("data matches more than one schema in oneOf(TransitionState)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(TransitionState)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src TransitionState) MarshalJSON() ([]byte, error) {
	if src.AudienceEntryState != nil {
		return json.Marshal(&src.AudienceEntryState)
	}

	if src.ConditionSplitState != nil {
		return json.Marshal(&src.ConditionSplitState)
	}

	if src.DestinationState != nil {
		return json.Marshal(&src.DestinationState)
	}

	if src.EventEntryState != nil {
		return json.Marshal(&src.EventEntryState)
	}

	if src.EventSplitWithTimeoutState != nil {
		return json.Marshal(&src.EventSplitWithTimeoutState)
	}

	if src.RandomSplitState != nil {
		return json.Marshal(&src.RandomSplitState)
	}

	if src.SimpleDelayState != nil {
		return json.Marshal(&src.SimpleDelayState)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *TransitionState) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.AudienceEntryState != nil {
		return obj.AudienceEntryState
	}

	if obj.ConditionSplitState != nil {
		return obj.ConditionSplitState
	}

	if obj.DestinationState != nil {
		return obj.DestinationState
	}

	if obj.EventEntryState != nil {
		return obj.EventEntryState
	}

	if obj.EventSplitWithTimeoutState != nil {
		return obj.EventSplitWithTimeoutState
	}

	if obj.RandomSplitState != nil {
		return obj.RandomSplitState
	}

	if obj.SimpleDelayState != nil {
		return obj.SimpleDelayState
	}

	// all schemas are nil
	return nil
}

type NullableTransitionState struct {
	value *TransitionState
	isSet bool
}

func (v NullableTransitionState) Get() *TransitionState {
	return v.value
}

func (v *NullableTransitionState) Set(val *TransitionState) {
	v.value = val
	v.isSet = true
}

func (v NullableTransitionState) IsSet() bool {
	return v.isSet
}

func (v *NullableTransitionState) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTransitionState(val *TransitionState) *NullableTransitionState {
	return &NullableTransitionState{value: val, isSet: true}
}

func (v NullableTransitionState) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTransitionState) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

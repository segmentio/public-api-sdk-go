/*
Segment Public API

The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.

API version: 34.3.5
Contact: friends@segment.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// ProfilesSelectiveSyncApiService ProfilesSelectiveSyncApi service
type ProfilesSelectiveSyncApiService service

type ApiListSelectiveSyncsFromWarehouseAndSpaceRequest struct {
	ctx         context.Context
	ApiService  *ProfilesSelectiveSyncApiService
	spaceId     string
	warehouseId string
	pagination  *PaginationInput
}

// Defines the pagination parameters.  This parameter exists in alpha.
func (r ApiListSelectiveSyncsFromWarehouseAndSpaceRequest) Pagination(
	pagination PaginationInput,
) ApiListSelectiveSyncsFromWarehouseAndSpaceRequest {
	r.pagination = &pagination
	return r
}

func (r ApiListSelectiveSyncsFromWarehouseAndSpaceRequest) Execute() (*ListSelectiveSyncsFromWarehouseAndSpace200Response, *http.Response, error) {
	return r.ApiService.ListSelectiveSyncsFromWarehouseAndSpaceExecute(r)
}

/*
ListSelectiveSyncsFromWarehouseAndSpace List Selective Syncs from Warehouse And Space

Returns the schema for a Space Warehouse connection, including Sources, Collections, and Properties.

â€¢ When called, this endpoint may generate the `Profiles Sync Warehouse Schema Retrieved` event in the [audit trail](/tag/Audit-Trail).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId
	@param warehouseId
	@return ApiListSelectiveSyncsFromWarehouseAndSpaceRequest
*/
func (a *ProfilesSelectiveSyncApiService) ListSelectiveSyncsFromWarehouseAndSpace(
	ctx context.Context,
	spaceId string,
	warehouseId string,
) ApiListSelectiveSyncsFromWarehouseAndSpaceRequest {
	return ApiListSelectiveSyncsFromWarehouseAndSpaceRequest{
		ApiService:  a,
		ctx:         ctx,
		spaceId:     spaceId,
		warehouseId: warehouseId,
	}
}

// Execute executes the request
//
//	@return ListSelectiveSyncsFromWarehouseAndSpace200Response
func (a *ProfilesSelectiveSyncApiService) ListSelectiveSyncsFromWarehouseAndSpaceExecute(
	r ApiListSelectiveSyncsFromWarehouseAndSpaceRequest,
) (*ListSelectiveSyncsFromWarehouseAndSpace200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSelectiveSyncsFromWarehouseAndSpace200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(
		r.ctx,
		"ProfilesSelectiveSyncApiService.ListSelectiveSyncsFromWarehouseAndSpace",
	)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/profiles-warehouses/{warehouseId}/selective-syncs"
	localVarPath = strings.Replace(
		localVarPath,
		"{"+"spaceId"+"}",
		url.PathEscape(parameterToString(r.spaceId, "")),
		-1,
	)
	localVarPath = strings.Replace(
		localVarPath,
		"{"+"warehouseId"+"}",
		url.PathEscape(parameterToString(r.warehouseId, "")),
		-1,
	)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pagination == nil {
		return localVarReturnValue, nil, reportError("pagination is required and must be specified")
	}

	localVarQueryParams.Add("pagination", parameterToString(*r.pagination, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/vnd.segment.v1alpha+json",
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(
		r.ctx,
		localVarPath,
		localVarHTTPMethod,
		localVarPostBody,
		localVarHeaderParams,
		localVarQueryParams,
		localVarFormParams,
		formFiles,
	)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(
		&localVarReturnValue,
		localVarBody,
		localVarHTTPResponse.Header.Get("Content-Type"),
	)
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

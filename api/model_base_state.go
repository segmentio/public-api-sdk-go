/*
Segment Public API

The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.

API version: 58.1.1
Contact: friends@segment.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// BaseState - struct for BaseState
type BaseState struct {
	ExitDestinationState *ExitDestinationState
	ExitRule             *ExitRule
	ExitState            *ExitState
	TransitionState      *TransitionState
}

// ExitDestinationStateAsBaseState is a convenience function that returns ExitDestinationState wrapped in BaseState
func ExitDestinationStateAsBaseState(v *ExitDestinationState) BaseState {
	return BaseState{
		ExitDestinationState: v,
	}
}

// ExitRuleAsBaseState is a convenience function that returns ExitRule wrapped in BaseState
func ExitRuleAsBaseState(v *ExitRule) BaseState {
	return BaseState{
		ExitRule: v,
	}
}

// ExitStateAsBaseState is a convenience function that returns ExitState wrapped in BaseState
func ExitStateAsBaseState(v *ExitState) BaseState {
	return BaseState{
		ExitState: v,
	}
}

// TransitionStateAsBaseState is a convenience function that returns TransitionState wrapped in BaseState
func TransitionStateAsBaseState(v *TransitionState) BaseState {
	return BaseState{
		TransitionState: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *BaseState) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ExitDestinationState
	err = newStrictDecoder(data).Decode(&dst.ExitDestinationState)
	if err == nil {
		jsonExitDestinationState, _ := json.Marshal(dst.ExitDestinationState)
		if string(jsonExitDestinationState) == "{}" { // empty struct
			dst.ExitDestinationState = nil
		} else {
			match++
		}
	} else {
		dst.ExitDestinationState = nil
	}

	// try to unmarshal data into ExitRule
	err = newStrictDecoder(data).Decode(&dst.ExitRule)
	if err == nil {
		jsonExitRule, _ := json.Marshal(dst.ExitRule)
		if string(jsonExitRule) == "{}" { // empty struct
			dst.ExitRule = nil
		} else {
			match++
		}
	} else {
		dst.ExitRule = nil
	}

	// try to unmarshal data into ExitState
	err = newStrictDecoder(data).Decode(&dst.ExitState)
	if err == nil {
		jsonExitState, _ := json.Marshal(dst.ExitState)
		if string(jsonExitState) == "{}" { // empty struct
			dst.ExitState = nil
		} else {
			match++
		}
	} else {
		dst.ExitState = nil
	}

	// try to unmarshal data into TransitionState
	err = newStrictDecoder(data).Decode(&dst.TransitionState)
	if err == nil {
		jsonTransitionState, _ := json.Marshal(dst.TransitionState)
		if string(jsonTransitionState) == "{}" { // empty struct
			dst.TransitionState = nil
		} else {
			match++
		}
	} else {
		dst.TransitionState = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ExitDestinationState = nil
		dst.ExitRule = nil
		dst.ExitState = nil
		dst.TransitionState = nil

		return fmt.Errorf("data matches more than one schema in oneOf(BaseState)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(BaseState)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src BaseState) MarshalJSON() ([]byte, error) {
	if src.ExitDestinationState != nil {
		return json.Marshal(&src.ExitDestinationState)
	}

	if src.ExitRule != nil {
		return json.Marshal(&src.ExitRule)
	}

	if src.ExitState != nil {
		return json.Marshal(&src.ExitState)
	}

	if src.TransitionState != nil {
		return json.Marshal(&src.TransitionState)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *BaseState) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.ExitDestinationState != nil {
		return obj.ExitDestinationState
	}

	if obj.ExitRule != nil {
		return obj.ExitRule
	}

	if obj.ExitState != nil {
		return obj.ExitState
	}

	if obj.TransitionState != nil {
		return obj.TransitionState
	}

	// all schemas are nil
	return nil
}

type NullableBaseState struct {
	value *BaseState
	isSet bool
}

func (v NullableBaseState) Get() *BaseState {
	return v.value
}

func (v *NullableBaseState) Set(val *BaseState) {
	v.value = val
	v.isSet = true
}

func (v NullableBaseState) IsSet() bool {
	return v.isSet
}

func (v *NullableBaseState) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBaseState(val *BaseState) *NullableBaseState {
	return &NullableBaseState{value: val, isSet: true}
}

func (v NullableBaseState) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBaseState) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
